抓取Hacker News的最新文章

### one
创建一个名为one.js的新文件及js内容：
```
- run()函数现在返回了一个Promise, 因此异步前缀已移至Promise函数的定义
- 还将所有代码包装在try-catch块中, 以便我们处理导致承诺被拒绝的任何错误。
- 使用的是Puppeteer的内置方法, 名为validate()
    - 通过此方法, 可以像在DevTools控制台中执行自定义JavaScript代码一样运行它。
    - 从该函数返回的任何内容都可以由promise解决。
    - 当涉及到抓取信息或执行自定义操作时, 此方法非常方便。
- 传递给valuate()方法的代码是非常基本的JavaScript, 该JavaScript构建了一个对象数组, 每个对象都有表示我们在https://news.ycombinator.com/上看到的故事URL的URL和文本字段
```
上面只有第一页, 而还有更多可用页面-它们仅在其他页面上。需要单击”更多”按钮以加载下一页结果

### two 脚本以添加对分页的支持：
回顾一下这里所做的事情：
```
- 在主要的run()函数中添加了一个名为pagesToScrape的参数。
    - 我们将使用它来限制脚本抓取的页面数。
- 一个currentPage的新变量, 它表示我们当前正在查看的结果页面数。
    - 最初设置为1
    - 我们还将validate()函数包装在while循环中, 以便只要currentPage小于或等于pagesToScrape, 它就可以继续运行。
- 添加了用于移动到新页面并等待页面加载的块, 然后重新启动while循环。
```
使用了page.click()方法让无头浏览器单击”更多”按钮。我们还使用了waitForSelector()方法来确保逻辑被暂停, 直到页面内容被加载
两种都是可立即使用的高级Puppeteer API方法。

在使用Puppeteer进行抓取时, 你可能会遇到的问题之一是等待页面加载。 对于具有相对简单的结构, 等待页面加载完成相当容易。
对于更复杂的用例, Puppeteer提供了广泛的内置功能, 你可以在GitHub的API文档中进行探索。


一切都很酷, 但是我们的Puppeteer教程尚未涵盖优化。让我们看看如何使Puppeteer更快地运行

### Three 优化Puppeteer脚本
总体思路是不要让无头浏览器做任何额外的工作。这可能包括加载图像, 应用CSS规则, 触发XHR请求等。

与其他工具一样, Puppeteer的优化取决于确切的用例, 因此请记住, 其中一些想法可能不适合你的项目。
例如, 如果我们在第一个示例中避免加载图像, 则我们的屏幕截图可能看起来并不像我们想要的那样。
无论如何, 这些优化可以通过在第一个请求上缓存资产或在网站发起HTTP请求时直接取消它们来实现。

缓存的工作原理: 
- 当启动新的无头浏览器实例时, Puppeteer为其配置文件创建一个临时目录。
- 当浏览器关闭时, 它将被删除, 并且在启动新实例时将无法使用它-因此将不再可访问所有存储的图像, CSS, Cookie和其他对象。
- 因此可以强制Puppeteer使用自定义路径来存储cookie和缓存之类的数据, 每次我们再次运行它们时, 它们将被重用-直到它们过期或被手动删除。
```js
const browser = await puppeteer.launch({
    userDataDir: './data', });
```
这会给我们带来很大的性能提升, 因为在第一次请求时, 许多CSS和图像都会缓存在数据目录中, 而Chrome不需要一次又一次地下载它们。

但呈现页面时仍将使用这些资产(图像, css 等)。在我们搜寻文章的中不需要担心任何视觉效果, 包括图像。我们只关心裸露的HTML输出, 因此让我们尝试阻止每个请求。

在这种情况下, Puppeteer非常好用, 因为它附带了对自定义钩子的支持。我们可以为每个请求提供拦截器, 并取消我们真正不需要的请求。
拦截器可以通过以下方式定义：
```js
await page.setRequestInterception(true);
page.on('request', (request) => {
    if (request.resourceType() === 'document') {
        request.continue();
    } else {
        request.abort();
    }
});
```
- 对启动的请求具有完全控制权。
- 可以编写自定义逻辑, 以根据请求的resourceType允许或中止特定请求。
- 还可以访问许多其他数据, 例如request.url, 因此如果需要, 可以仅阻止特定的URL。
- 上面示例仅允许资源类型为” document”的请求通过过滤器, 意味着将**阻止所有图像, CSS以及除原始HTML响应之外的所有其他内容**

### 通过速率限制保持安全
无头浏览器是非常强大的工具。几乎可以执行任何类型的网络自动化任务, 而Puppeteer则使这一工作变得更加轻松。
尽管有各种可能性, 必须遵守网站的服务条款, 以确保不会滥用该系统。
减慢Puppeteer脚本速度的最基本方法是向其添加sleep命令：
```js 
// ...
await page.waitFor(5000);
// ...
browser.close();
```
- 此语句将强制脚本休眠五秒钟(5000毫秒)
- 可以将其放在browser.close()之前的任何位置。

就像限制第三方服务的使用一样, 还有许多其他更健壮的方法来控制对Puppeteer的使用。
一个示例是建立一个工作人员数量有限的队列系统。每次你想要使用Puppeteer时, 都会将一个新任务推送到队列中, 但是只有少数工作人员能够处理其中的任务。在处理第三方API速率限制时, 这是一种相当普遍的做法, 也可以应用于Puppeteer Web数据抓取。

### Puppeteer在快速发展的网络中的地位
在此演示了其基本功能作为网络抓取工具。但是它具有更广泛的用例, 包括无头浏览器测试, PDF生成和性能监控等
